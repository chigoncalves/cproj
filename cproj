#!/usr/bin/env perl

package CProject;
use 5.020;
use warnings q/all/;
use autodie;

use Cwd qw/abs_path/;
use File::Basename qw/dirname/;
use File::Path qw/make_path/;
use File::Spec::Functions qw/catdir/;
use YAML::Tiny;
use File::Temp qw/:seekable/;
use Env qw/HOME/;
use Getopt::Long;
use Carp qw/croak/;

sub new {
  my $class = shift;
  my $self = {
       base_dir => dirname abs_path (__FILE__),
       manifest => [],
       language => 'C',
       description => 'Simple Project.',
  };

  my $doc = YAML::Tiny->read (catdir ($self->{base_dir},
				      'manifest.yml'));
  $self->{manifest} = \@{${$doc->[0]}{'manifest'}};

  my @ARGV = @main::ARGV;
  if (scalar @ARGV < 2 || $ARGV[0] ne 'new') {
    CProjectCli::Utils->usage;
  }

  shift @ARGV;
  $self->{project_name} = shift @ARGV;
  $self->{project_dirname} = CProjectCli::Utils->convert_to_file_name ($self->{project_name});
  $self->{project_dirpath} = abs_path $self->{project_dirname};

  my $parser = Getopt::Long::Parser->new;
  my %options = (language => 'c',
		 description => 'Simple Project.',
		 qt => 0);
  $parser->getoptionsfromarray (\@ARGV,
				'language|l=s' => \$options{language},
				'description|d=s' => \$options{description},
				'qt|q' => \$options{qt},
			       )
    ;

  $self->{language} = delete $options{language};
  $self->{description} = delete $options{description};

  my $valid_language = 0;
  $self->{language} = uc $self->{language};
  for my $lang (qw/C CC CXX CPP/) {
    if ($lang eq $self->{language}) {
      $valid_language = 1;
      last;
    }
  }

  unless ($valid_language) {
    croak 'Invalid language! Language must be one of C or [CC, CXX, CPP]';
  }

  if ($self->{language} eq 'C') {
    $self->{C} = {
		  CONFIG => 'config.h',
		  IO => 'stdio.h',
		  STD => 'stdlib.h',
		  SNIPPET => '  printf ("Project -> \"%s\".\n", PROJECT_NAME);',
		  HEADER => 'h',
		  SOURCE => 'c',
		  UNUSED => '  UNUSED (argc, argv);\n',
		  EXIT_STATUS => 'EXIT_SUCCESS',
		  MORE_HEADERS => '',
		 };

  }
  else {
    $self->{language} = 'CXX';
    $self->{CXX} = {
		    CONFIG => 'config.hh',
		    IO => 'iostream',
		    STD => 'cstdlib',
		    SNIPPET => '  std::cout << "Project -> \"" << PROJECT_NAME << "\"." << std::endl;',
		    HEADER => 'hh',
		    SOURCE => 'cc',
		    UNUSED => 'UNUSED (argc, argv);\n',
		    EXIT_STATUS => 'EXIT_SUCCESS',
		    MORE_HEADERS => '',
		   };

    if ($options{qt}) {
      $self->{CXX}->{SNIPPET} = <<'SNIPPET';
  QApplication app (argc, argv);
  QMainWindow window;
  window.setWindowTitle (PROJECT_NAME_STR);
  window.resize (600, 480);
  window.move (QApplication::desktop ()->screen ()->rect ().center ()
	       - window.rect ().center ());
  window.show ();
SNIPPET

      $self->{CXX}->{EXIT_STATUS} = 'app.exec ()';
      $self->{CXX}->{UNUSED} = '';
      $self->{CXX}->{MORE_HEADERS} = <<'MORE_HEADERS';
#include <QApplication>
#include <QDesktopWidget>
#include <QMainWindow>
MORE_HEADERS
    }
  }

  bless $self, $class;
}

sub process_templates {
  my $self = shift;
  my %params = @_;

  my $files = delete $params{files};
  my ($IN, $OUT, @param_vars) = (undef, undef, (keys %params));
  # my @templates = ());

  for my $file (@$files) {
    open ($IN, '<', catdir ($self->{base_dir}, $file));
    open ($OUT, '>', catdir ($self->{project_dirpath}, $file));

    while (my $line = readline $IN) {
      chomp $line;
      for my $param (@param_vars) {
  	$line =~ s/%$param%/$params{$param}/g;
      }
      say {$OUT} $line;
    }
    close $IN;
    close $OUT;
    $IN = $OUT = undef;
  }
}

sub run {
  my $self = shift;

  if (-d $self->{project_dirpath}) {
    die "`$self->{project_dirname}' exists! Try a diferent name.\n";
  }
  make_path $self->{project_dirpath};

  for my $dirent (@{$self->{manifest}}) {
    my $src_path = catdir $self->{base_dir}, $dirent;
    my $dest_path = catdir $self->{project_dirpath}, $dirent;
    CProjectCli::Utils->copy_file ($src_path, $dest_path);
  }

  $self->process_templates (files => ['CMakeLists.txt', 'readme.rst',
				      '.dir-locals.el',
				      catdir ('src', 'config.h.in'),
				      catdir ('src', 'main.c'),],
			    APP_NAME => $self->{project_dirname},
			    PROJECT => $self->{project_name},
			    PROJECT_MACRO =>
			    CProjectCli::Utils->
			    convert_to_macro_identifier (
			    $self->{project_dirname}),
			    USER => $ENV{USER},
			    EMAIL => "$ENV{USER}\@localhost",
			    DIR_PATH => $self->{project_dirpath},
			    DESCRIPTION => $self->{description},
			    LANG => $self->{language},
			    %{$self->{$self->{language}}},
			   );

  my $fh = File::Temp->new (TEMPLATE => "cproj-XXXXXXXXX",
			    SUFFIX => '.rst',
			    CLEANUP => 1,
			    TMPDIR => 1);

  my $readme_fname = catdir $self->{project_dirpath}, 'readme.rst';

  CProjectCli::Utils->copy_file ($readme_fname, $fh->filename, 1);

  open (my $README_FH, '>', $readme_fname);
  $fh->seek (0, SEEK_SET);

  my $section_set = 0;
  while (my $line = $fh->getline ()) {
    chomp $line;

    next if $line =~ /^(#|\*|=|-|~){3,}/;

    unless ($section_set) {
      my $len = length ($line) + 2;
      say {$README_FH} '#' x $len;
      say {$README_FH} sprintf (' %s', $line);
      say {$README_FH} '#' x $len;
      $section_set = 1;
      next;
    }

    say {$README_FH} $line;
  }

  if ($self->{language} eq 'CXX') {
    for my $file (qw/config.h.in main.c/) {
      my $old_file = catdir $self->{project_dirpath}, 'src', $file;
      my $new_file = $old_file;
      $new_file =~ s%\.h%.hh%;
      $new_file =~ s%\.c%\.cc%;
      rename $old_file, $new_file;
    }
  }
}


package CProjectCli::Utils;

use 5.020;
use warnings q/all/;
use autodie;

use File::Copy qw/copy/;
use File::Basename qw/dirname/;
use File::Path qw/make_path/;

sub usage {
  die "[USAGE]:\n\tcproj new <project-name>\n";
}

sub convert_to_macro_identifier {
  shift;
  my $name = uc shift;

  $name =~ s/(\W|^\d)/_/g;
  $name =~ s/_+/_/g;
  $name =~ s/(^_|_$)//g;

  return $name;
}

sub convert_to_file_name {
  my $name = lc $_[1];
  $name =~ s/(\s|_)+/-/g;

  return $name;
}

sub copy_file {
  my ($self, $src, $dest, $overwrite) = @_;

  return if -e $dest && !$overwrite;

  if (-f $src) {
    my $dest_dname = dirname $dest;
    make_path $dest_dname unless -e $dest_dname;
    copy $src, $dest;
  }
}


package main;

CProject->new->run;
