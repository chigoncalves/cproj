#!/usr/bin/env perl

use 5.020;
use warnings;
use autodie;
use feature q/signatures/;
use subs qw/usage path_abs name_for_macro process_templates/;
no warnings q/experimental::signatures/;

use Cwd q/cwd/;
use File::Spec::Functions q/catdir/;
use File::Copy::Recursive qw/fcopy dircopy/;
use File::Path q/make_path/;
use File::Basename q/basename/;

use constant {
  BASE_DIR => catdir ($ENV{SLNC_COD_DIR}, 'cproj'),
  CWD => cwd,
};

sub usage () {
  die "[USAGE]: cproj new PROJECT-NAME\n";
}

sub name_for_macro ($name) {
  $name = uc $name;
  $name =~ s/(\W|^\d)/_/g;
  $name =~ s/_+/_/g;
  $name =~ s/(^_|_$)//g;

  return $name;
}

sub path_abs ($path) {
  return $path =~ m|^(~?/)| ? $path : catdir CWD, $path;
}

sub process_templates (%params) {
  my $path = path_abs delete $params{path};

  my ($IN, $OUT, @param_vars) = (undef, undef, (keys %params));
  my @templates = (catdir ('include', 'config.h.in'), 'CMakeLists.txt', 'readme.rst');
  for my $file (@templates) {
    open ($IN, '<', catdir (BASE_DIR, $file));
    open ($OUT, '>', catdir ($path, $file));

    while (my $line = readline $IN) {
      chomp $line;
      for my $param (@param_vars) {
	$line =~ s/%$param%/$params{$param}/g;
      }
      say {$OUT} $line;
    }
    close $IN;
    close $OUT;
    $IN = $OUT = undef;
  }
}

usage if scalar @ARGV != 2 || $ARGV[0] ne 'new';

my ($proj_name, $path) = (basename ($ARGV[1]), path_abs $ARGV[1]);

die "`$proj_name` exists! Try a diferent name.\n" if -e $path;

make_path $proj_name;

for my $dir (qw/include src doc lib cmake/) {
  dircopy catdir(BASE_DIR, $dir), catdir ($path, $dir);
}

fcopy catdir (BASE_DIR, 'readme.rst'), catdir ($path, 'readme.rst');

process_templates PROJECT => name_for_macro($proj_name), APP_NAME => $proj_name,
	  USER => $ENV{USER}, EMAIL => "$ENV{USER}\@localhost", path => $path;
